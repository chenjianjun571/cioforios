// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: jsbn_bss.proto

#ifndef PROTOBUF_jsbn_5fbss_2eproto__INCLUDED
#define PROTOBUF_jsbn_5fbss_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace jsbn {
    namespace protoc {
        
        // Internal implementation detail -- do not call these.
        void  protobuf_AddDesc_jsbn_5fbss_2eproto();
        void protobuf_AssignDesc_jsbn_5fbss_2eproto();
        void protobuf_ShutdownFile_jsbn_5fbss_2eproto();
        
        class LoginRequest;
        class LoginResponse;
        class BSSNetProtocol;
        
        enum MSG {
            Heart_Beat = 0,
            Login_Request = 4097,
            Login_Response = 4098
        };
        bool MSG_IsValid(int value);
        const MSG MSG_MIN = Heart_Beat;
        const MSG MSG_MAX = Login_Response;
        const int MSG_ARRAYSIZE = MSG_MAX + 1;
        
        // ===================================================================
        
        class LoginRequest : public ::google::protobuf::MessageLite {
        public:
            LoginRequest();
            virtual ~LoginRequest();
            
            LoginRequest(const LoginRequest& from);
            
            inline LoginRequest& operator=(const LoginRequest& from) {
                CopyFrom(from);
                return *this;
            }
            
            inline const ::std::string& unknown_fields() const {
                return _unknown_fields_;
            }
            
            inline ::std::string* mutable_unknown_fields() {
                return &_unknown_fields_;
            }
            
            static const LoginRequest& default_instance();
            
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            // Returns the internal default instance pointer. This function can
            // return NULL thus should not be used by the user. This is intended
            // for Protobuf internal code. Please use default_instance() declared
            // above instead.
            static inline const LoginRequest* internal_default_instance() {
                return default_instance_;
            }
#endif
            
            void Swap(LoginRequest* other);
            
            // implements Message ----------------------------------------------
            
            LoginRequest* New() const;
            void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
            void CopyFrom(const LoginRequest& from);
            void MergeFrom(const LoginRequest& from);
            void Clear();
            bool IsInitialized() const;
            
            int ByteSize() const;
            bool MergePartialFromCodedStream(
                                             ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                                          ::google::protobuf::io::CodedOutputStream* output) const;
            void DiscardUnknownFields();
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:
            ::std::string GetTypeName() const;
            
            // nested types ----------------------------------------------------
            
            // accessors -------------------------------------------------------
            
            // required bytes username = 1;
            inline bool has_username() const;
            inline void clear_username();
            static const int kUsernameFieldNumber = 1;
            inline const ::std::string& username() const;
            inline void set_username(const ::std::string& value);
            inline void set_username(const char* value);
            inline void set_username(const void* value, size_t size);
            inline ::std::string* mutable_username();
            inline ::std::string* release_username();
            inline void set_allocated_username(::std::string* username);
            
            // required string password = 2;
            inline bool has_password() const;
            inline void clear_password();
            static const int kPasswordFieldNumber = 2;
            inline const ::std::string& password() const;
            inline void set_password(const ::std::string& value);
            inline void set_password(const char* value);
            inline void set_password(const char* value, size_t size);
            inline ::std::string* mutable_password();
            inline ::std::string* release_password();
            inline void set_allocated_password(::std::string* password);
            
            // @@protoc_insertion_point(class_scope:jsbn.protoc.LoginRequest)
        private:
            inline void set_has_username();
            inline void clear_has_username();
            inline void set_has_password();
            inline void clear_has_password();
            
            ::std::string _unknown_fields_;
            
            ::google::protobuf::uint32 _has_bits_[1];
            mutable int _cached_size_;
            ::std::string* username_;
            ::std::string* password_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto_impl();
#else
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto();
#endif
            friend void protobuf_AssignDesc_jsbn_5fbss_2eproto();
            friend void protobuf_ShutdownFile_jsbn_5fbss_2eproto();
            
            void InitAsDefaultInstance();
            static LoginRequest* default_instance_;
        };
        // -------------------------------------------------------------------
        
        class LoginResponse : public ::google::protobuf::MessageLite {
        public:
            LoginResponse();
            virtual ~LoginResponse();
            
            LoginResponse(const LoginResponse& from);
            
            inline LoginResponse& operator=(const LoginResponse& from) {
                CopyFrom(from);
                return *this;
            }
            
            inline const ::std::string& unknown_fields() const {
                return _unknown_fields_;
            }
            
            inline ::std::string* mutable_unknown_fields() {
                return &_unknown_fields_;
            }
            
            static const LoginResponse& default_instance();
            
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            // Returns the internal default instance pointer. This function can
            // return NULL thus should not be used by the user. This is intended
            // for Protobuf internal code. Please use default_instance() declared
            // above instead.
            static inline const LoginResponse* internal_default_instance() {
                return default_instance_;
            }
#endif
            
            void Swap(LoginResponse* other);
            
            // implements Message ----------------------------------------------
            
            LoginResponse* New() const;
            void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
            void CopyFrom(const LoginResponse& from);
            void MergeFrom(const LoginResponse& from);
            void Clear();
            bool IsInitialized() const;
            
            int ByteSize() const;
            bool MergePartialFromCodedStream(
                                             ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                                          ::google::protobuf::io::CodedOutputStream* output) const;
            void DiscardUnknownFields();
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:
            ::std::string GetTypeName() const;
            
            // nested types ----------------------------------------------------
            
            // accessors -------------------------------------------------------
            
            // required fixed32 result = 1;
            inline bool has_result() const;
            inline void clear_result();
            static const int kResultFieldNumber = 1;
            inline ::google::protobuf::uint32 result() const;
            inline void set_result(::google::protobuf::uint32 value);
            
            // optional bytes error_description = 2;
            inline bool has_error_description() const;
            inline void clear_error_description();
            static const int kErrorDescriptionFieldNumber = 2;
            inline const ::std::string& error_description() const;
            inline void set_error_description(const ::std::string& value);
            inline void set_error_description(const char* value);
            inline void set_error_description(const void* value, size_t size);
            inline ::std::string* mutable_error_description();
            inline ::std::string* release_error_description();
            inline void set_allocated_error_description(::std::string* error_description);
            
            // @@protoc_insertion_point(class_scope:jsbn.protoc.LoginResponse)
        private:
            inline void set_has_result();
            inline void clear_has_result();
            inline void set_has_error_description();
            inline void clear_has_error_description();
            
            ::std::string _unknown_fields_;
            
            ::google::protobuf::uint32 _has_bits_[1];
            mutable int _cached_size_;
            ::std::string* error_description_;
            ::google::protobuf::uint32 result_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto_impl();
#else
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto();
#endif
            friend void protobuf_AssignDesc_jsbn_5fbss_2eproto();
            friend void protobuf_ShutdownFile_jsbn_5fbss_2eproto();
            
            void InitAsDefaultInstance();
            static LoginResponse* default_instance_;
        };
        // -------------------------------------------------------------------
        
        class BSSNetProtocol : public ::google::protobuf::MessageLite {
        public:
            BSSNetProtocol();
            virtual ~BSSNetProtocol();
            
            BSSNetProtocol(const BSSNetProtocol& from);
            
            inline BSSNetProtocol& operator=(const BSSNetProtocol& from) {
                CopyFrom(from);
                return *this;
            }
            
            inline const ::std::string& unknown_fields() const {
                return _unknown_fields_;
            }
            
            inline ::std::string* mutable_unknown_fields() {
                return &_unknown_fields_;
            }
            
            static const BSSNetProtocol& default_instance();
            
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            // Returns the internal default instance pointer. This function can
            // return NULL thus should not be used by the user. This is intended
            // for Protobuf internal code. Please use default_instance() declared
            // above instead.
            static inline const BSSNetProtocol* internal_default_instance() {
                return default_instance_;
            }
#endif
            
            void Swap(BSSNetProtocol* other);
            
            // implements Message ----------------------------------------------
            
            BSSNetProtocol* New() const;
            void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
            void CopyFrom(const BSSNetProtocol& from);
            void MergeFrom(const BSSNetProtocol& from);
            void Clear();
            bool IsInitialized() const;
            
            int ByteSize() const;
            bool MergePartialFromCodedStream(
                                             ::google::protobuf::io::CodedInputStream* input);
            void SerializeWithCachedSizes(
                                          ::google::protobuf::io::CodedOutputStream* output) const;
            void DiscardUnknownFields();
            int GetCachedSize() const { return _cached_size_; }
        private:
            void SharedCtor();
            void SharedDtor();
            void SetCachedSize(int size) const;
        public:
            ::std::string GetTypeName() const;
            
            // nested types ----------------------------------------------------
            
            // accessors -------------------------------------------------------
            
            // required .jsbn.protoc.MSG type = 1;
            inline bool has_type() const;
            inline void clear_type();
            static const int kTypeFieldNumber = 1;
            inline ::jsbn::protoc::MSG type() const;
            inline void set_type(::jsbn::protoc::MSG value);
            
            // optional .jsbn.protoc.LoginRequest loginrequest = 3;
            inline bool has_loginrequest() const;
            inline void clear_loginrequest();
            static const int kLoginrequestFieldNumber = 3;
            inline const ::jsbn::protoc::LoginRequest& loginrequest() const;
            inline ::jsbn::protoc::LoginRequest* mutable_loginrequest();
            inline ::jsbn::protoc::LoginRequest* release_loginrequest();
            inline void set_allocated_loginrequest(::jsbn::protoc::LoginRequest* loginrequest);
            
            // optional .jsbn.protoc.LoginResponse loginresponse = 4;
            inline bool has_loginresponse() const;
            inline void clear_loginresponse();
            static const int kLoginresponseFieldNumber = 4;
            inline const ::jsbn::protoc::LoginResponse& loginresponse() const;
            inline ::jsbn::protoc::LoginResponse* mutable_loginresponse();
            inline ::jsbn::protoc::LoginResponse* release_loginresponse();
            inline void set_allocated_loginresponse(::jsbn::protoc::LoginResponse* loginresponse);
            
            // @@protoc_insertion_point(class_scope:jsbn.protoc.BSSNetProtocol)
        private:
            inline void set_has_type();
            inline void clear_has_type();
            inline void set_has_loginrequest();
            inline void clear_has_loginrequest();
            inline void set_has_loginresponse();
            inline void clear_has_loginresponse();
            
            ::std::string _unknown_fields_;
            
            ::google::protobuf::uint32 _has_bits_[1];
            mutable int _cached_size_;
            ::jsbn::protoc::LoginRequest* loginrequest_;
            ::jsbn::protoc::LoginResponse* loginresponse_;
            int type_;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto_impl();
#else
            friend void  protobuf_AddDesc_jsbn_5fbss_2eproto();
#endif
            friend void protobuf_AssignDesc_jsbn_5fbss_2eproto();
            friend void protobuf_ShutdownFile_jsbn_5fbss_2eproto();
            
            void InitAsDefaultInstance();
            static BSSNetProtocol* default_instance_;
        };
        // ===================================================================
        
        
        // ===================================================================
        
        // LoginRequest
        
        // required bytes username = 1;
        inline bool LoginRequest::has_username() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void LoginRequest::set_has_username() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void LoginRequest::clear_has_username() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void LoginRequest::clear_username() {
            if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                username_->clear();
            }
            clear_has_username();
        }
        inline const ::std::string& LoginRequest::username() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.LoginRequest.username)
            return *username_;
        }
        inline void LoginRequest::set_username(const ::std::string& value) {
            set_has_username();
            if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                username_ = new ::std::string;
            }
            username_->assign(value);
            // @@protoc_insertion_point(field_set:jsbn.protoc.LoginRequest.username)
        }
        inline void LoginRequest::set_username(const char* value) {
            set_has_username();
            if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                username_ = new ::std::string;
            }
            username_->assign(value);
            // @@protoc_insertion_point(field_set_char:jsbn.protoc.LoginRequest.username)
        }
        inline void LoginRequest::set_username(const void* value, size_t size) {
            set_has_username();
            if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                username_ = new ::std::string;
            }
            username_->assign(reinterpret_cast<const char*>(value), size);
            // @@protoc_insertion_point(field_set_pointer:jsbn.protoc.LoginRequest.username)
        }
        inline ::std::string* LoginRequest::mutable_username() {
            set_has_username();
            if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                username_ = new ::std::string;
            }
            // @@protoc_insertion_point(field_mutable:jsbn.protoc.LoginRequest.username)
            return username_;
        }
        inline ::std::string* LoginRequest::release_username() {
            clear_has_username();
            if (username_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                return NULL;
            } else {
                ::std::string* temp = username_;
                username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
                return temp;
            }
        }
        inline void LoginRequest::set_allocated_username(::std::string* username) {
            if (username_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                delete username_;
            }
            if (username) {
                set_has_username();
                username_ = username;
            } else {
                clear_has_username();
                username_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            // @@protoc_insertion_point(field_set_allocated:jsbn.protoc.LoginRequest.username)
        }
        
        // required string password = 2;
        inline bool LoginRequest::has_password() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void LoginRequest::set_has_password() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void LoginRequest::clear_has_password() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void LoginRequest::clear_password() {
            if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                password_->clear();
            }
            clear_has_password();
        }
        inline const ::std::string& LoginRequest::password() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.LoginRequest.password)
            return *password_;
        }
        inline void LoginRequest::set_password(const ::std::string& value) {
            set_has_password();
            if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                password_ = new ::std::string;
            }
            password_->assign(value);
            // @@protoc_insertion_point(field_set:jsbn.protoc.LoginRequest.password)
        }
        inline void LoginRequest::set_password(const char* value) {
            set_has_password();
            if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                password_ = new ::std::string;
            }
            password_->assign(value);
            // @@protoc_insertion_point(field_set_char:jsbn.protoc.LoginRequest.password)
        }
        inline void LoginRequest::set_password(const char* value, size_t size) {
            set_has_password();
            if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                password_ = new ::std::string;
            }
            password_->assign(reinterpret_cast<const char*>(value), size);
            // @@protoc_insertion_point(field_set_pointer:jsbn.protoc.LoginRequest.password)
        }
        inline ::std::string* LoginRequest::mutable_password() {
            set_has_password();
            if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                password_ = new ::std::string;
            }
            // @@protoc_insertion_point(field_mutable:jsbn.protoc.LoginRequest.password)
            return password_;
        }
        inline ::std::string* LoginRequest::release_password() {
            clear_has_password();
            if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                return NULL;
            } else {
                ::std::string* temp = password_;
                password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
                return temp;
            }
        }
        inline void LoginRequest::set_allocated_password(::std::string* password) {
            if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                delete password_;
            }
            if (password) {
                set_has_password();
                password_ = password;
            } else {
                clear_has_password();
                password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            // @@protoc_insertion_point(field_set_allocated:jsbn.protoc.LoginRequest.password)
        }
        
        // -------------------------------------------------------------------
        
        // LoginResponse
        
        // required fixed32 result = 1;
        inline bool LoginResponse::has_result() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void LoginResponse::set_has_result() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void LoginResponse::clear_has_result() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void LoginResponse::clear_result() {
            result_ = 0u;
            clear_has_result();
        }
        inline ::google::protobuf::uint32 LoginResponse::result() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.LoginResponse.result)
            return result_;
        }
        inline void LoginResponse::set_result(::google::protobuf::uint32 value) {
            set_has_result();
            result_ = value;
            // @@protoc_insertion_point(field_set:jsbn.protoc.LoginResponse.result)
        }
        
        // optional bytes error_description = 2;
        inline bool LoginResponse::has_error_description() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void LoginResponse::set_has_error_description() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void LoginResponse::clear_has_error_description() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void LoginResponse::clear_error_description() {
            if (error_description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                error_description_->clear();
            }
            clear_has_error_description();
        }
        inline const ::std::string& LoginResponse::error_description() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.LoginResponse.error_description)
            return *error_description_;
        }
        inline void LoginResponse::set_error_description(const ::std::string& value) {
            set_has_error_description();
            if (error_description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                error_description_ = new ::std::string;
            }
            error_description_->assign(value);
            // @@protoc_insertion_point(field_set:jsbn.protoc.LoginResponse.error_description)
        }
        inline void LoginResponse::set_error_description(const char* value) {
            set_has_error_description();
            if (error_description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                error_description_ = new ::std::string;
            }
            error_description_->assign(value);
            // @@protoc_insertion_point(field_set_char:jsbn.protoc.LoginResponse.error_description)
        }
        inline void LoginResponse::set_error_description(const void* value, size_t size) {
            set_has_error_description();
            if (error_description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                error_description_ = new ::std::string;
            }
            error_description_->assign(reinterpret_cast<const char*>(value), size);
            // @@protoc_insertion_point(field_set_pointer:jsbn.protoc.LoginResponse.error_description)
        }
        inline ::std::string* LoginResponse::mutable_error_description() {
            set_has_error_description();
            if (error_description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                error_description_ = new ::std::string;
            }
            // @@protoc_insertion_point(field_mutable:jsbn.protoc.LoginResponse.error_description)
            return error_description_;
        }
        inline ::std::string* LoginResponse::release_error_description() {
            clear_has_error_description();
            if (error_description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                return NULL;
            } else {
                ::std::string* temp = error_description_;
                error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
                return temp;
            }
        }
        inline void LoginResponse::set_allocated_error_description(::std::string* error_description) {
            if (error_description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
                delete error_description_;
            }
            if (error_description) {
                set_has_error_description();
                error_description_ = error_description;
            } else {
                clear_has_error_description();
                error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
            }
            // @@protoc_insertion_point(field_set_allocated:jsbn.protoc.LoginResponse.error_description)
        }
        
        // -------------------------------------------------------------------
        
        // BSSNetProtocol
        
        // required .jsbn.protoc.MSG type = 1;
        inline bool BSSNetProtocol::has_type() const {
            return (_has_bits_[0] & 0x00000001u) != 0;
        }
        inline void BSSNetProtocol::set_has_type() {
            _has_bits_[0] |= 0x00000001u;
        }
        inline void BSSNetProtocol::clear_has_type() {
            _has_bits_[0] &= ~0x00000001u;
        }
        inline void BSSNetProtocol::clear_type() {
            type_ = 0;
            clear_has_type();
        }
        inline ::jsbn::protoc::MSG BSSNetProtocol::type() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.BSSNetProtocol.type)
            return static_cast< ::jsbn::protoc::MSG >(type_);
        }
        inline void BSSNetProtocol::set_type(::jsbn::protoc::MSG value) {
            assert(::jsbn::protoc::MSG_IsValid(value));
            set_has_type();
            type_ = value;
            // @@protoc_insertion_point(field_set:jsbn.protoc.BSSNetProtocol.type)
        }
        
        // optional .jsbn.protoc.LoginRequest loginrequest = 3;
        inline bool BSSNetProtocol::has_loginrequest() const {
            return (_has_bits_[0] & 0x00000002u) != 0;
        }
        inline void BSSNetProtocol::set_has_loginrequest() {
            _has_bits_[0] |= 0x00000002u;
        }
        inline void BSSNetProtocol::clear_has_loginrequest() {
            _has_bits_[0] &= ~0x00000002u;
        }
        inline void BSSNetProtocol::clear_loginrequest() {
            if (loginrequest_ != NULL) loginrequest_->::jsbn::protoc::LoginRequest::Clear();
            clear_has_loginrequest();
        }
        inline const ::jsbn::protoc::LoginRequest& BSSNetProtocol::loginrequest() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.BSSNetProtocol.loginrequest)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            return loginrequest_ != NULL ? *loginrequest_ : *default_instance().loginrequest_;
#else
            return loginrequest_ != NULL ? *loginrequest_ : *default_instance_->loginrequest_;
#endif
        }
        inline ::jsbn::protoc::LoginRequest* BSSNetProtocol::mutable_loginrequest() {
            set_has_loginrequest();
            if (loginrequest_ == NULL) loginrequest_ = new ::jsbn::protoc::LoginRequest;
            // @@protoc_insertion_point(field_mutable:jsbn.protoc.BSSNetProtocol.loginrequest)
            return loginrequest_;
        }
        inline ::jsbn::protoc::LoginRequest* BSSNetProtocol::release_loginrequest() {
            clear_has_loginrequest();
            ::jsbn::protoc::LoginRequest* temp = loginrequest_;
            loginrequest_ = NULL;
            return temp;
        }
        inline void BSSNetProtocol::set_allocated_loginrequest(::jsbn::protoc::LoginRequest* loginrequest) {
            delete loginrequest_;
            loginrequest_ = loginrequest;
            if (loginrequest) {
                set_has_loginrequest();
            } else {
                clear_has_loginrequest();
            }
            // @@protoc_insertion_point(field_set_allocated:jsbn.protoc.BSSNetProtocol.loginrequest)
        }
        
        // optional .jsbn.protoc.LoginResponse loginresponse = 4;
        inline bool BSSNetProtocol::has_loginresponse() const {
            return (_has_bits_[0] & 0x00000004u) != 0;
        }
        inline void BSSNetProtocol::set_has_loginresponse() {
            _has_bits_[0] |= 0x00000004u;
        }
        inline void BSSNetProtocol::clear_has_loginresponse() {
            _has_bits_[0] &= ~0x00000004u;
        }
        inline void BSSNetProtocol::clear_loginresponse() {
            if (loginresponse_ != NULL) loginresponse_->::jsbn::protoc::LoginResponse::Clear();
            clear_has_loginresponse();
        }
        inline const ::jsbn::protoc::LoginResponse& BSSNetProtocol::loginresponse() const {
            // @@protoc_insertion_point(field_get:jsbn.protoc.BSSNetProtocol.loginresponse)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
            return loginresponse_ != NULL ? *loginresponse_ : *default_instance().loginresponse_;
#else
            return loginresponse_ != NULL ? *loginresponse_ : *default_instance_->loginresponse_;
#endif
        }
        inline ::jsbn::protoc::LoginResponse* BSSNetProtocol::mutable_loginresponse() {
            set_has_loginresponse();
            if (loginresponse_ == NULL) loginresponse_ = new ::jsbn::protoc::LoginResponse;
            // @@protoc_insertion_point(field_mutable:jsbn.protoc.BSSNetProtocol.loginresponse)
            return loginresponse_;
        }
        inline ::jsbn::protoc::LoginResponse* BSSNetProtocol::release_loginresponse() {
            clear_has_loginresponse();
            ::jsbn::protoc::LoginResponse* temp = loginresponse_;
            loginresponse_ = NULL;
            return temp;
        }
        inline void BSSNetProtocol::set_allocated_loginresponse(::jsbn::protoc::LoginResponse* loginresponse) {
            delete loginresponse_;
            loginresponse_ = loginresponse;
            if (loginresponse) {
                set_has_loginresponse();
            } else {
                clear_has_loginresponse();
            }
            // @@protoc_insertion_point(field_set_allocated:jsbn.protoc.BSSNetProtocol.loginresponse)
        }
        
        
        // @@protoc_insertion_point(namespace_scope)
        
    }  // namespace protoc
}  // namespace jsbn

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_jsbn_5fbss_2eproto__INCLUDED
